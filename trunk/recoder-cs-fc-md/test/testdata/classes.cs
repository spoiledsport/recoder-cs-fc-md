
using smallbug;

using bigbug = smallbug.bigger;

namespace hello {
    namespace world {
        using xxx;
    }
    namespace forever {
    }
}



namespace a {
    
    namespace b {
    
        class Y : K,L {

          class Z {
          
              new public protected internal private static readonly volatile 
                  X field;
            
            sbyte[] field2;
            
             // TODO: Initializer Test
            
            class A : B {
            
                public protected internal private extern A (object x): base (x) {
                    const int[] a = 2;
                
                    System.Console.WriteLine("Construct!!!");
                    return this;
                }
            
            }
            
          }

        }    
    }

}


class Hello {

  class World {
      new  public protected internal private static virtual sealed 
      override abstract extern 
                  void method(uint ui,ref int i,out String str) {
                      int j;
                      
                      try {
                          Winnie();
                          The.Pooh();
                          System.Console.WriteLine("Hello World");
                      }
                      
                      catch (GoToHellException) {
                          if ( a && b ) {
                              return true;
                              }
                              else 
                                  return new object();    
                      }
      }
      
      void test() {
        SomeObject a;
        
        a++;
        a[2]++;
        
        (a as object)++;
        
      }
      
      ushort method2();
      
      const int a = 3, c = 2;
      int[] b = {1,2,3,4};
      
      static extern Hello () {
         juhuuu();
      }
      
      ~Hello() {
          System.Console.WriteLine("HEY! I'M A DESTRUCTOR!");
//          2.11223.toString(a,b,c);
//          true.toString();
//          0x2234.toString();
//          2.toString();
      }
      
      Mokus operator + ( int a ) {
          return new Mokus();
      }
      
      explicit operator object(int x) {
      }
      
      implicit operator string(Exception a) {
      }
      
      
      public int this [ int a, int b, int c ] {
          get { } 
          set ;
      }
      
      public int aProp {
          set {
             acc.set(aProp);
          }
      }
          
      public int BFace.Iface . this [ int x, Y c, A b ] {
          get {
           hello();
          }
       }

    public static int get() {
        this[567]++;
        base[666]++;
    
    }

  }
  
}


namespace error.test {

    class H {
    }
    
    struct I {
    }
    
//    delegate void J();
        
}

namespace doubleerror {

namespace error.test {
    class K {
    }
    
    struct L {
    }
    
//    delegate void M();
}


}